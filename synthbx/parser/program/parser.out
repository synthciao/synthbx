Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> unit_list
Rule 2     unit_list -> unit
Rule 3     unit_list -> unit unit_list
Rule 4     unit -> type_decl
Rule 5     unit -> relation_decl
Rule 6     unit -> directive
Rule 7     unit -> rule
Rule 8     unit -> fact
Rule 9     type_decl -> TYPE IDENT
Rule 10    type_decl -> TYPE IDENT SUBTYPE type_name
Rule 11    type_decl -> TYPE IDENT EQ type_name
Rule 12    relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN
Rule 13    relation_decl -> DECL IDENT LPAREN RPAREN
Rule 14    directive -> INPUT_DECL ident_list
Rule 15    directive -> OUTPUT_DECL ident_list
Rule 16    rule -> head IF body DOT
Rule 17    fact -> atom DOT
Rule 18    head -> atom
Rule 19    body -> conjunction
Rule 20    body -> conjunction SEMICOLON conjunction_list
Rule 21    conjunction_list -> conjunction
Rule 22    conjunction_list -> conjunction SEMICOLON conjunction_list
Rule 23    conjunction -> item
Rule 24    conjunction -> item COMMA item_list
Rule 25    item_list -> item
Rule 26    item_list -> item COMMA item_list
Rule 27    item -> atom
Rule 28    item -> negation
Rule 29    item -> constraint
Rule 30    atom -> IDENT LPAREN argument_list RPAREN
Rule 31    atom -> IDENT LPAREN RPAREN
Rule 32    negation -> NOT atom
Rule 33    constraint -> variable EQ constant
Rule 34    constraint -> variable NE constant
Rule 35    constraint -> variable GT constant
Rule 36    constraint -> variable LT constant
Rule 37    constraint -> variable GE constant
Rule 38    constraint -> variable LE constant
Rule 39    ident_list -> IDENT
Rule 40    ident_list -> IDENT COMMA ident_list
Rule 41    attribute_decl_list -> attribute_decl
Rule 42    attribute_decl_list -> attribute_decl COMMA attribute_decl_list
Rule 43    attribute_decl -> IDENT COLON type_name
Rule 44    type_name -> NUMBER
Rule 45    type_name -> SYMBOL
Rule 46    type_name -> IDENT
Rule 47    argument_list -> argument
Rule 48    argument_list -> argument COMMA argument_list
Rule 49    argument -> variable
Rule 50    argument -> constant
Rule 51    variable -> IDENT
Rule 52    variable -> UNDERSCORE
Rule 53    constant -> STRING
Rule 54    constant -> INTEGER

Terminals, with rules where they appear

COLON                : 43
COMMA                : 24 26 40 42 48
DECL                 : 12 13
DOT                  : 16 17
EQ                   : 11 33
GE                   : 37
GT                   : 35
IDENT                : 9 10 11 12 13 30 31 39 40 43 46 51
IF                   : 16
INPUT_DECL           : 14
INTEGER              : 54
LE                   : 38
LPAREN               : 12 13 30 31
LT                   : 36
NE                   : 34
NOT                  : 32
NUMBER               : 44
OUTPUT_DECL          : 15
RPAREN               : 12 13 30 31
SEMICOLON            : 20 22
STRING               : 53
SUBTYPE              : 10
SYMBOL               : 45
TYPE                 : 9 10 11
UNDERSCORE           : 52
error                : 

Nonterminals, with rules where they appear

argument             : 47 48
argument_list        : 30 48
atom                 : 17 18 27 32
attribute_decl       : 41 42
attribute_decl_list  : 12 42
body                 : 16
conjunction          : 19 20 21 22
conjunction_list     : 20 22
constant             : 33 34 35 36 37 38 50
constraint           : 29
directive            : 6
fact                 : 8
head                 : 16
ident_list           : 14 15 40
item                 : 23 24 25 26
item_list            : 24 26
negation             : 28
program              : 0
relation_decl        : 5
rule                 : 7
type_decl            : 4
type_name            : 10 11 43
unit                 : 2 3
unit_list            : 1 3
variable             : 33 34 35 36 37 38 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . unit_list
    (2) unit_list -> . unit
    (3) unit_list -> . unit unit_list
    (4) unit -> . type_decl
    (5) unit -> . relation_decl
    (6) unit -> . directive
    (7) unit -> . rule
    (8) unit -> . fact
    (9) type_decl -> . TYPE IDENT
    (10) type_decl -> . TYPE IDENT SUBTYPE type_name
    (11) type_decl -> . TYPE IDENT EQ type_name
    (12) relation_decl -> . DECL IDENT LPAREN attribute_decl_list RPAREN
    (13) relation_decl -> . DECL IDENT LPAREN RPAREN
    (14) directive -> . INPUT_DECL ident_list
    (15) directive -> . OUTPUT_DECL ident_list
    (16) rule -> . head IF body DOT
    (17) fact -> . atom DOT
    (18) head -> . atom
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN

    TYPE            shift and go to state 9
    DECL            shift and go to state 11
    INPUT_DECL      shift and go to state 12
    OUTPUT_DECL     shift and go to state 13
    IDENT           shift and go to state 10

    program                        shift and go to state 1
    unit_list                      shift and go to state 2
    unit                           shift and go to state 3
    type_decl                      shift and go to state 4
    relation_decl                  shift and go to state 5
    directive                      shift and go to state 6
    rule                           shift and go to state 7
    fact                           shift and go to state 8
    head                           shift and go to state 14
    atom                           shift and go to state 15

state 1

    (0) S' -> program .



state 2

    (1) program -> unit_list .

    $end            reduce using rule 1 (program -> unit_list .)


state 3

    (2) unit_list -> unit .
    (3) unit_list -> unit . unit_list
    (2) unit_list -> . unit
    (3) unit_list -> . unit unit_list
    (4) unit -> . type_decl
    (5) unit -> . relation_decl
    (6) unit -> . directive
    (7) unit -> . rule
    (8) unit -> . fact
    (9) type_decl -> . TYPE IDENT
    (10) type_decl -> . TYPE IDENT SUBTYPE type_name
    (11) type_decl -> . TYPE IDENT EQ type_name
    (12) relation_decl -> . DECL IDENT LPAREN attribute_decl_list RPAREN
    (13) relation_decl -> . DECL IDENT LPAREN RPAREN
    (14) directive -> . INPUT_DECL ident_list
    (15) directive -> . OUTPUT_DECL ident_list
    (16) rule -> . head IF body DOT
    (17) fact -> . atom DOT
    (18) head -> . atom
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN

    $end            reduce using rule 2 (unit_list -> unit .)
    TYPE            shift and go to state 9
    DECL            shift and go to state 11
    INPUT_DECL      shift and go to state 12
    OUTPUT_DECL     shift and go to state 13
    IDENT           shift and go to state 10

    unit                           shift and go to state 3
    unit_list                      shift and go to state 16
    type_decl                      shift and go to state 4
    relation_decl                  shift and go to state 5
    directive                      shift and go to state 6
    rule                           shift and go to state 7
    fact                           shift and go to state 8
    head                           shift and go to state 14
    atom                           shift and go to state 15

state 4

    (4) unit -> type_decl .

    TYPE            reduce using rule 4 (unit -> type_decl .)
    DECL            reduce using rule 4 (unit -> type_decl .)
    INPUT_DECL      reduce using rule 4 (unit -> type_decl .)
    OUTPUT_DECL     reduce using rule 4 (unit -> type_decl .)
    IDENT           reduce using rule 4 (unit -> type_decl .)
    $end            reduce using rule 4 (unit -> type_decl .)


state 5

    (5) unit -> relation_decl .

    TYPE            reduce using rule 5 (unit -> relation_decl .)
    DECL            reduce using rule 5 (unit -> relation_decl .)
    INPUT_DECL      reduce using rule 5 (unit -> relation_decl .)
    OUTPUT_DECL     reduce using rule 5 (unit -> relation_decl .)
    IDENT           reduce using rule 5 (unit -> relation_decl .)
    $end            reduce using rule 5 (unit -> relation_decl .)


state 6

    (6) unit -> directive .

    TYPE            reduce using rule 6 (unit -> directive .)
    DECL            reduce using rule 6 (unit -> directive .)
    INPUT_DECL      reduce using rule 6 (unit -> directive .)
    OUTPUT_DECL     reduce using rule 6 (unit -> directive .)
    IDENT           reduce using rule 6 (unit -> directive .)
    $end            reduce using rule 6 (unit -> directive .)


state 7

    (7) unit -> rule .

    TYPE            reduce using rule 7 (unit -> rule .)
    DECL            reduce using rule 7 (unit -> rule .)
    INPUT_DECL      reduce using rule 7 (unit -> rule .)
    OUTPUT_DECL     reduce using rule 7 (unit -> rule .)
    IDENT           reduce using rule 7 (unit -> rule .)
    $end            reduce using rule 7 (unit -> rule .)


state 8

    (8) unit -> fact .

    TYPE            reduce using rule 8 (unit -> fact .)
    DECL            reduce using rule 8 (unit -> fact .)
    INPUT_DECL      reduce using rule 8 (unit -> fact .)
    OUTPUT_DECL     reduce using rule 8 (unit -> fact .)
    IDENT           reduce using rule 8 (unit -> fact .)
    $end            reduce using rule 8 (unit -> fact .)


state 9

    (9) type_decl -> TYPE . IDENT
    (10) type_decl -> TYPE . IDENT SUBTYPE type_name
    (11) type_decl -> TYPE . IDENT EQ type_name

    IDENT           shift and go to state 17


state 10

    (30) atom -> IDENT . LPAREN argument_list RPAREN
    (31) atom -> IDENT . LPAREN RPAREN

    LPAREN          shift and go to state 18


state 11

    (12) relation_decl -> DECL . IDENT LPAREN attribute_decl_list RPAREN
    (13) relation_decl -> DECL . IDENT LPAREN RPAREN

    IDENT           shift and go to state 19


state 12

    (14) directive -> INPUT_DECL . ident_list
    (39) ident_list -> . IDENT
    (40) ident_list -> . IDENT COMMA ident_list

    IDENT           shift and go to state 21

    ident_list                     shift and go to state 20

state 13

    (15) directive -> OUTPUT_DECL . ident_list
    (39) ident_list -> . IDENT
    (40) ident_list -> . IDENT COMMA ident_list

    IDENT           shift and go to state 21

    ident_list                     shift and go to state 22

state 14

    (16) rule -> head . IF body DOT

    IF              shift and go to state 23


state 15

    (17) fact -> atom . DOT
    (18) head -> atom .

    DOT             shift and go to state 24
    IF              reduce using rule 18 (head -> atom .)


state 16

    (3) unit_list -> unit unit_list .

    $end            reduce using rule 3 (unit_list -> unit unit_list .)


state 17

    (9) type_decl -> TYPE IDENT .
    (10) type_decl -> TYPE IDENT . SUBTYPE type_name
    (11) type_decl -> TYPE IDENT . EQ type_name

    TYPE            reduce using rule 9 (type_decl -> TYPE IDENT .)
    DECL            reduce using rule 9 (type_decl -> TYPE IDENT .)
    INPUT_DECL      reduce using rule 9 (type_decl -> TYPE IDENT .)
    OUTPUT_DECL     reduce using rule 9 (type_decl -> TYPE IDENT .)
    IDENT           reduce using rule 9 (type_decl -> TYPE IDENT .)
    $end            reduce using rule 9 (type_decl -> TYPE IDENT .)
    SUBTYPE         shift and go to state 25
    EQ              shift and go to state 26


state 18

    (30) atom -> IDENT LPAREN . argument_list RPAREN
    (31) atom -> IDENT LPAREN . RPAREN
    (47) argument_list -> . argument
    (48) argument_list -> . argument COMMA argument_list
    (49) argument -> . variable
    (50) argument -> . constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    RPAREN          shift and go to state 29
    IDENT           shift and go to state 27
    UNDERSCORE      shift and go to state 33
    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    argument_list                  shift and go to state 28
    argument                       shift and go to state 30
    variable                       shift and go to state 31
    constant                       shift and go to state 32

state 19

    (12) relation_decl -> DECL IDENT . LPAREN attribute_decl_list RPAREN
    (13) relation_decl -> DECL IDENT . LPAREN RPAREN

    LPAREN          shift and go to state 36


state 20

    (14) directive -> INPUT_DECL ident_list .

    TYPE            reduce using rule 14 (directive -> INPUT_DECL ident_list .)
    DECL            reduce using rule 14 (directive -> INPUT_DECL ident_list .)
    INPUT_DECL      reduce using rule 14 (directive -> INPUT_DECL ident_list .)
    OUTPUT_DECL     reduce using rule 14 (directive -> INPUT_DECL ident_list .)
    IDENT           reduce using rule 14 (directive -> INPUT_DECL ident_list .)
    $end            reduce using rule 14 (directive -> INPUT_DECL ident_list .)


state 21

    (39) ident_list -> IDENT .
    (40) ident_list -> IDENT . COMMA ident_list

    TYPE            reduce using rule 39 (ident_list -> IDENT .)
    DECL            reduce using rule 39 (ident_list -> IDENT .)
    INPUT_DECL      reduce using rule 39 (ident_list -> IDENT .)
    OUTPUT_DECL     reduce using rule 39 (ident_list -> IDENT .)
    IDENT           reduce using rule 39 (ident_list -> IDENT .)
    $end            reduce using rule 39 (ident_list -> IDENT .)
    COMMA           shift and go to state 37


state 22

    (15) directive -> OUTPUT_DECL ident_list .

    TYPE            reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)
    DECL            reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)
    INPUT_DECL      reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)
    OUTPUT_DECL     reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)
    IDENT           reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)
    $end            reduce using rule 15 (directive -> OUTPUT_DECL ident_list .)


state 23

    (16) rule -> head IF . body DOT
    (19) body -> . conjunction
    (20) body -> . conjunction SEMICOLON conjunction_list
    (23) conjunction -> . item
    (24) conjunction -> . item COMMA item_list
    (27) item -> . atom
    (28) item -> . negation
    (29) item -> . constraint
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN
    (32) negation -> . NOT atom
    (33) constraint -> . variable EQ constant
    (34) constraint -> . variable NE constant
    (35) constraint -> . variable GT constant
    (36) constraint -> . variable LT constant
    (37) constraint -> . variable GE constant
    (38) constraint -> . variable LE constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE

    IDENT           shift and go to state 44
    NOT             shift and go to state 45
    UNDERSCORE      shift and go to state 33

    body                           shift and go to state 38
    conjunction                    shift and go to state 39
    item                           shift and go to state 40
    atom                           shift and go to state 41
    negation                       shift and go to state 42
    constraint                     shift and go to state 43
    variable                       shift and go to state 46

state 24

    (17) fact -> atom DOT .

    TYPE            reduce using rule 17 (fact -> atom DOT .)
    DECL            reduce using rule 17 (fact -> atom DOT .)
    INPUT_DECL      reduce using rule 17 (fact -> atom DOT .)
    OUTPUT_DECL     reduce using rule 17 (fact -> atom DOT .)
    IDENT           reduce using rule 17 (fact -> atom DOT .)
    $end            reduce using rule 17 (fact -> atom DOT .)


state 25

    (10) type_decl -> TYPE IDENT SUBTYPE . type_name
    (44) type_name -> . NUMBER
    (45) type_name -> . SYMBOL
    (46) type_name -> . IDENT

    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    IDENT           shift and go to state 47

    type_name                      shift and go to state 48

state 26

    (11) type_decl -> TYPE IDENT EQ . type_name
    (44) type_name -> . NUMBER
    (45) type_name -> . SYMBOL
    (46) type_name -> . IDENT

    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    IDENT           shift and go to state 47

    type_name                      shift and go to state 51

state 27

    (51) variable -> IDENT .

    COMMA           reduce using rule 51 (variable -> IDENT .)
    RPAREN          reduce using rule 51 (variable -> IDENT .)


state 28

    (30) atom -> IDENT LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 52


state 29

    (31) atom -> IDENT LPAREN RPAREN .

    DOT             reduce using rule 31 (atom -> IDENT LPAREN RPAREN .)
    IF              reduce using rule 31 (atom -> IDENT LPAREN RPAREN .)
    COMMA           reduce using rule 31 (atom -> IDENT LPAREN RPAREN .)
    SEMICOLON       reduce using rule 31 (atom -> IDENT LPAREN RPAREN .)


state 30

    (47) argument_list -> argument .
    (48) argument_list -> argument . COMMA argument_list

    RPAREN          reduce using rule 47 (argument_list -> argument .)
    COMMA           shift and go to state 53


state 31

    (49) argument -> variable .

    COMMA           reduce using rule 49 (argument -> variable .)
    RPAREN          reduce using rule 49 (argument -> variable .)


state 32

    (50) argument -> constant .

    COMMA           reduce using rule 50 (argument -> constant .)
    RPAREN          reduce using rule 50 (argument -> constant .)


state 33

    (52) variable -> UNDERSCORE .

    COMMA           reduce using rule 52 (variable -> UNDERSCORE .)
    RPAREN          reduce using rule 52 (variable -> UNDERSCORE .)
    EQ              reduce using rule 52 (variable -> UNDERSCORE .)
    NE              reduce using rule 52 (variable -> UNDERSCORE .)
    GT              reduce using rule 52 (variable -> UNDERSCORE .)
    LT              reduce using rule 52 (variable -> UNDERSCORE .)
    GE              reduce using rule 52 (variable -> UNDERSCORE .)
    LE              reduce using rule 52 (variable -> UNDERSCORE .)


state 34

    (53) constant -> STRING .

    COMMA           reduce using rule 53 (constant -> STRING .)
    RPAREN          reduce using rule 53 (constant -> STRING .)
    SEMICOLON       reduce using rule 53 (constant -> STRING .)
    DOT             reduce using rule 53 (constant -> STRING .)


state 35

    (54) constant -> INTEGER .

    COMMA           reduce using rule 54 (constant -> INTEGER .)
    RPAREN          reduce using rule 54 (constant -> INTEGER .)
    SEMICOLON       reduce using rule 54 (constant -> INTEGER .)
    DOT             reduce using rule 54 (constant -> INTEGER .)


state 36

    (12) relation_decl -> DECL IDENT LPAREN . attribute_decl_list RPAREN
    (13) relation_decl -> DECL IDENT LPAREN . RPAREN
    (41) attribute_decl_list -> . attribute_decl
    (42) attribute_decl_list -> . attribute_decl COMMA attribute_decl_list
    (43) attribute_decl -> . IDENT COLON type_name

    RPAREN          shift and go to state 56
    IDENT           shift and go to state 54

    attribute_decl_list            shift and go to state 55
    attribute_decl                 shift and go to state 57

state 37

    (40) ident_list -> IDENT COMMA . ident_list
    (39) ident_list -> . IDENT
    (40) ident_list -> . IDENT COMMA ident_list

    IDENT           shift and go to state 21

    ident_list                     shift and go to state 58

state 38

    (16) rule -> head IF body . DOT

    DOT             shift and go to state 59


state 39

    (19) body -> conjunction .
    (20) body -> conjunction . SEMICOLON conjunction_list

    DOT             reduce using rule 19 (body -> conjunction .)
    SEMICOLON       shift and go to state 60


state 40

    (23) conjunction -> item .
    (24) conjunction -> item . COMMA item_list

    SEMICOLON       reduce using rule 23 (conjunction -> item .)
    DOT             reduce using rule 23 (conjunction -> item .)
    COMMA           shift and go to state 61


state 41

    (27) item -> atom .

    COMMA           reduce using rule 27 (item -> atom .)
    SEMICOLON       reduce using rule 27 (item -> atom .)
    DOT             reduce using rule 27 (item -> atom .)


state 42

    (28) item -> negation .

    COMMA           reduce using rule 28 (item -> negation .)
    SEMICOLON       reduce using rule 28 (item -> negation .)
    DOT             reduce using rule 28 (item -> negation .)


state 43

    (29) item -> constraint .

    COMMA           reduce using rule 29 (item -> constraint .)
    SEMICOLON       reduce using rule 29 (item -> constraint .)
    DOT             reduce using rule 29 (item -> constraint .)


state 44

    (30) atom -> IDENT . LPAREN argument_list RPAREN
    (31) atom -> IDENT . LPAREN RPAREN
    (51) variable -> IDENT .

    LPAREN          shift and go to state 18
    EQ              reduce using rule 51 (variable -> IDENT .)
    NE              reduce using rule 51 (variable -> IDENT .)
    GT              reduce using rule 51 (variable -> IDENT .)
    LT              reduce using rule 51 (variable -> IDENT .)
    GE              reduce using rule 51 (variable -> IDENT .)
    LE              reduce using rule 51 (variable -> IDENT .)


state 45

    (32) negation -> NOT . atom
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN

    IDENT           shift and go to state 10

    atom                           shift and go to state 62

state 46

    (33) constraint -> variable . EQ constant
    (34) constraint -> variable . NE constant
    (35) constraint -> variable . GT constant
    (36) constraint -> variable . LT constant
    (37) constraint -> variable . GE constant
    (38) constraint -> variable . LE constant

    EQ              shift and go to state 63
    NE              shift and go to state 64
    GT              shift and go to state 65
    LT              shift and go to state 66
    GE              shift and go to state 67
    LE              shift and go to state 68


state 47

    (46) type_name -> IDENT .

    TYPE            reduce using rule 46 (type_name -> IDENT .)
    DECL            reduce using rule 46 (type_name -> IDENT .)
    INPUT_DECL      reduce using rule 46 (type_name -> IDENT .)
    OUTPUT_DECL     reduce using rule 46 (type_name -> IDENT .)
    IDENT           reduce using rule 46 (type_name -> IDENT .)
    $end            reduce using rule 46 (type_name -> IDENT .)
    COMMA           reduce using rule 46 (type_name -> IDENT .)
    RPAREN          reduce using rule 46 (type_name -> IDENT .)


state 48

    (10) type_decl -> TYPE IDENT SUBTYPE type_name .

    TYPE            reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)
    DECL            reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)
    INPUT_DECL      reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)
    OUTPUT_DECL     reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)
    IDENT           reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)
    $end            reduce using rule 10 (type_decl -> TYPE IDENT SUBTYPE type_name .)


state 49

    (44) type_name -> NUMBER .

    TYPE            reduce using rule 44 (type_name -> NUMBER .)
    DECL            reduce using rule 44 (type_name -> NUMBER .)
    INPUT_DECL      reduce using rule 44 (type_name -> NUMBER .)
    OUTPUT_DECL     reduce using rule 44 (type_name -> NUMBER .)
    IDENT           reduce using rule 44 (type_name -> NUMBER .)
    $end            reduce using rule 44 (type_name -> NUMBER .)
    COMMA           reduce using rule 44 (type_name -> NUMBER .)
    RPAREN          reduce using rule 44 (type_name -> NUMBER .)


state 50

    (45) type_name -> SYMBOL .

    TYPE            reduce using rule 45 (type_name -> SYMBOL .)
    DECL            reduce using rule 45 (type_name -> SYMBOL .)
    INPUT_DECL      reduce using rule 45 (type_name -> SYMBOL .)
    OUTPUT_DECL     reduce using rule 45 (type_name -> SYMBOL .)
    IDENT           reduce using rule 45 (type_name -> SYMBOL .)
    $end            reduce using rule 45 (type_name -> SYMBOL .)
    COMMA           reduce using rule 45 (type_name -> SYMBOL .)
    RPAREN          reduce using rule 45 (type_name -> SYMBOL .)


state 51

    (11) type_decl -> TYPE IDENT EQ type_name .

    TYPE            reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)
    DECL            reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)
    INPUT_DECL      reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)
    OUTPUT_DECL     reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)
    IDENT           reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)
    $end            reduce using rule 11 (type_decl -> TYPE IDENT EQ type_name .)


state 52

    (30) atom -> IDENT LPAREN argument_list RPAREN .

    DOT             reduce using rule 30 (atom -> IDENT LPAREN argument_list RPAREN .)
    IF              reduce using rule 30 (atom -> IDENT LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 30 (atom -> IDENT LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 30 (atom -> IDENT LPAREN argument_list RPAREN .)


state 53

    (48) argument_list -> argument COMMA . argument_list
    (47) argument_list -> . argument
    (48) argument_list -> . argument COMMA argument_list
    (49) argument -> . variable
    (50) argument -> . constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    IDENT           shift and go to state 27
    UNDERSCORE      shift and go to state 33
    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    argument                       shift and go to state 30
    argument_list                  shift and go to state 69
    variable                       shift and go to state 31
    constant                       shift and go to state 32

state 54

    (43) attribute_decl -> IDENT . COLON type_name

    COLON           shift and go to state 70


state 55

    (12) relation_decl -> DECL IDENT LPAREN attribute_decl_list . RPAREN

    RPAREN          shift and go to state 71


state 56

    (13) relation_decl -> DECL IDENT LPAREN RPAREN .

    TYPE            reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)
    DECL            reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)
    INPUT_DECL      reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)
    OUTPUT_DECL     reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)
    IDENT           reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)
    $end            reduce using rule 13 (relation_decl -> DECL IDENT LPAREN RPAREN .)


state 57

    (41) attribute_decl_list -> attribute_decl .
    (42) attribute_decl_list -> attribute_decl . COMMA attribute_decl_list

    RPAREN          reduce using rule 41 (attribute_decl_list -> attribute_decl .)
    COMMA           shift and go to state 72


state 58

    (40) ident_list -> IDENT COMMA ident_list .

    TYPE            reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)
    DECL            reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)
    INPUT_DECL      reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)
    OUTPUT_DECL     reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)
    IDENT           reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)
    $end            reduce using rule 40 (ident_list -> IDENT COMMA ident_list .)


state 59

    (16) rule -> head IF body DOT .

    TYPE            reduce using rule 16 (rule -> head IF body DOT .)
    DECL            reduce using rule 16 (rule -> head IF body DOT .)
    INPUT_DECL      reduce using rule 16 (rule -> head IF body DOT .)
    OUTPUT_DECL     reduce using rule 16 (rule -> head IF body DOT .)
    IDENT           reduce using rule 16 (rule -> head IF body DOT .)
    $end            reduce using rule 16 (rule -> head IF body DOT .)


state 60

    (20) body -> conjunction SEMICOLON . conjunction_list
    (21) conjunction_list -> . conjunction
    (22) conjunction_list -> . conjunction SEMICOLON conjunction_list
    (23) conjunction -> . item
    (24) conjunction -> . item COMMA item_list
    (27) item -> . atom
    (28) item -> . negation
    (29) item -> . constraint
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN
    (32) negation -> . NOT atom
    (33) constraint -> . variable EQ constant
    (34) constraint -> . variable NE constant
    (35) constraint -> . variable GT constant
    (36) constraint -> . variable LT constant
    (37) constraint -> . variable GE constant
    (38) constraint -> . variable LE constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE

    IDENT           shift and go to state 44
    NOT             shift and go to state 45
    UNDERSCORE      shift and go to state 33

    conjunction                    shift and go to state 73
    conjunction_list               shift and go to state 74
    item                           shift and go to state 40
    atom                           shift and go to state 41
    negation                       shift and go to state 42
    constraint                     shift and go to state 43
    variable                       shift and go to state 46

state 61

    (24) conjunction -> item COMMA . item_list
    (25) item_list -> . item
    (26) item_list -> . item COMMA item_list
    (27) item -> . atom
    (28) item -> . negation
    (29) item -> . constraint
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN
    (32) negation -> . NOT atom
    (33) constraint -> . variable EQ constant
    (34) constraint -> . variable NE constant
    (35) constraint -> . variable GT constant
    (36) constraint -> . variable LT constant
    (37) constraint -> . variable GE constant
    (38) constraint -> . variable LE constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE

    IDENT           shift and go to state 44
    NOT             shift and go to state 45
    UNDERSCORE      shift and go to state 33

    item                           shift and go to state 75
    item_list                      shift and go to state 76
    atom                           shift and go to state 41
    negation                       shift and go to state 42
    constraint                     shift and go to state 43
    variable                       shift and go to state 46

state 62

    (32) negation -> NOT atom .

    COMMA           reduce using rule 32 (negation -> NOT atom .)
    SEMICOLON       reduce using rule 32 (negation -> NOT atom .)
    DOT             reduce using rule 32 (negation -> NOT atom .)


state 63

    (33) constraint -> variable EQ . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 77

state 64

    (34) constraint -> variable NE . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 78

state 65

    (35) constraint -> variable GT . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 79

state 66

    (36) constraint -> variable LT . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 80

state 67

    (37) constraint -> variable GE . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 81

state 68

    (38) constraint -> variable LE . constant
    (53) constant -> . STRING
    (54) constant -> . INTEGER

    STRING          shift and go to state 34
    INTEGER         shift and go to state 35

    constant                       shift and go to state 82

state 69

    (48) argument_list -> argument COMMA argument_list .

    RPAREN          reduce using rule 48 (argument_list -> argument COMMA argument_list .)


state 70

    (43) attribute_decl -> IDENT COLON . type_name
    (44) type_name -> . NUMBER
    (45) type_name -> . SYMBOL
    (46) type_name -> . IDENT

    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    IDENT           shift and go to state 47

    type_name                      shift and go to state 83

state 71

    (12) relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .

    TYPE            reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)
    DECL            reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)
    INPUT_DECL      reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)
    OUTPUT_DECL     reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)
    IDENT           reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)
    $end            reduce using rule 12 (relation_decl -> DECL IDENT LPAREN attribute_decl_list RPAREN .)


state 72

    (42) attribute_decl_list -> attribute_decl COMMA . attribute_decl_list
    (41) attribute_decl_list -> . attribute_decl
    (42) attribute_decl_list -> . attribute_decl COMMA attribute_decl_list
    (43) attribute_decl -> . IDENT COLON type_name

    IDENT           shift and go to state 54

    attribute_decl                 shift and go to state 57
    attribute_decl_list            shift and go to state 84

state 73

    (21) conjunction_list -> conjunction .
    (22) conjunction_list -> conjunction . SEMICOLON conjunction_list

    DOT             reduce using rule 21 (conjunction_list -> conjunction .)
    SEMICOLON       shift and go to state 85


state 74

    (20) body -> conjunction SEMICOLON conjunction_list .

    DOT             reduce using rule 20 (body -> conjunction SEMICOLON conjunction_list .)


state 75

    (25) item_list -> item .
    (26) item_list -> item . COMMA item_list

    SEMICOLON       reduce using rule 25 (item_list -> item .)
    DOT             reduce using rule 25 (item_list -> item .)
    COMMA           shift and go to state 86


state 76

    (24) conjunction -> item COMMA item_list .

    SEMICOLON       reduce using rule 24 (conjunction -> item COMMA item_list .)
    DOT             reduce using rule 24 (conjunction -> item COMMA item_list .)


state 77

    (33) constraint -> variable EQ constant .

    COMMA           reduce using rule 33 (constraint -> variable EQ constant .)
    SEMICOLON       reduce using rule 33 (constraint -> variable EQ constant .)
    DOT             reduce using rule 33 (constraint -> variable EQ constant .)


state 78

    (34) constraint -> variable NE constant .

    COMMA           reduce using rule 34 (constraint -> variable NE constant .)
    SEMICOLON       reduce using rule 34 (constraint -> variable NE constant .)
    DOT             reduce using rule 34 (constraint -> variable NE constant .)


state 79

    (35) constraint -> variable GT constant .

    COMMA           reduce using rule 35 (constraint -> variable GT constant .)
    SEMICOLON       reduce using rule 35 (constraint -> variable GT constant .)
    DOT             reduce using rule 35 (constraint -> variable GT constant .)


state 80

    (36) constraint -> variable LT constant .

    COMMA           reduce using rule 36 (constraint -> variable LT constant .)
    SEMICOLON       reduce using rule 36 (constraint -> variable LT constant .)
    DOT             reduce using rule 36 (constraint -> variable LT constant .)


state 81

    (37) constraint -> variable GE constant .

    COMMA           reduce using rule 37 (constraint -> variable GE constant .)
    SEMICOLON       reduce using rule 37 (constraint -> variable GE constant .)
    DOT             reduce using rule 37 (constraint -> variable GE constant .)


state 82

    (38) constraint -> variable LE constant .

    COMMA           reduce using rule 38 (constraint -> variable LE constant .)
    SEMICOLON       reduce using rule 38 (constraint -> variable LE constant .)
    DOT             reduce using rule 38 (constraint -> variable LE constant .)


state 83

    (43) attribute_decl -> IDENT COLON type_name .

    COMMA           reduce using rule 43 (attribute_decl -> IDENT COLON type_name .)
    RPAREN          reduce using rule 43 (attribute_decl -> IDENT COLON type_name .)


state 84

    (42) attribute_decl_list -> attribute_decl COMMA attribute_decl_list .

    RPAREN          reduce using rule 42 (attribute_decl_list -> attribute_decl COMMA attribute_decl_list .)


state 85

    (22) conjunction_list -> conjunction SEMICOLON . conjunction_list
    (21) conjunction_list -> . conjunction
    (22) conjunction_list -> . conjunction SEMICOLON conjunction_list
    (23) conjunction -> . item
    (24) conjunction -> . item COMMA item_list
    (27) item -> . atom
    (28) item -> . negation
    (29) item -> . constraint
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN
    (32) negation -> . NOT atom
    (33) constraint -> . variable EQ constant
    (34) constraint -> . variable NE constant
    (35) constraint -> . variable GT constant
    (36) constraint -> . variable LT constant
    (37) constraint -> . variable GE constant
    (38) constraint -> . variable LE constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE

    IDENT           shift and go to state 44
    NOT             shift and go to state 45
    UNDERSCORE      shift and go to state 33

    conjunction                    shift and go to state 73
    conjunction_list               shift and go to state 87
    item                           shift and go to state 40
    atom                           shift and go to state 41
    negation                       shift and go to state 42
    constraint                     shift and go to state 43
    variable                       shift and go to state 46

state 86

    (26) item_list -> item COMMA . item_list
    (25) item_list -> . item
    (26) item_list -> . item COMMA item_list
    (27) item -> . atom
    (28) item -> . negation
    (29) item -> . constraint
    (30) atom -> . IDENT LPAREN argument_list RPAREN
    (31) atom -> . IDENT LPAREN RPAREN
    (32) negation -> . NOT atom
    (33) constraint -> . variable EQ constant
    (34) constraint -> . variable NE constant
    (35) constraint -> . variable GT constant
    (36) constraint -> . variable LT constant
    (37) constraint -> . variable GE constant
    (38) constraint -> . variable LE constant
    (51) variable -> . IDENT
    (52) variable -> . UNDERSCORE

    IDENT           shift and go to state 44
    NOT             shift and go to state 45
    UNDERSCORE      shift and go to state 33

    item                           shift and go to state 75
    item_list                      shift and go to state 88
    atom                           shift and go to state 41
    negation                       shift and go to state 42
    constraint                     shift and go to state 43
    variable                       shift and go to state 46

state 87

    (22) conjunction_list -> conjunction SEMICOLON conjunction_list .

    DOT             reduce using rule 22 (conjunction_list -> conjunction SEMICOLON conjunction_list .)


state 88

    (26) item_list -> item COMMA item_list .

    SEMICOLON       reduce using rule 26 (item_list -> item COMMA item_list .)
    DOT             reduce using rule 26 (item_list -> item COMMA item_list .)

